#!/usr/bin/env bash

FILE=""
LOCALITY=""
DEBUG=0

function locality() {
  parse_args "$@"

  modify_file_name "${FILE}" "${LOCALITY}"
}

function parse_args() {
  if [[ -e "$1" ]]; then 
    FILE="$1";
  else 
    FILE=$(get_calling_file "$@")
  fi

  if [[ -e "$2" ]]; then 
    LOCALITY="$2";
  else 
    LOCALITY=$(read_locality_config) || { exit 1; }
  fi
}

# Get the name of the calling script 
# See here: https://www.experts-exchange.com/questions/25025178/Determine-the-name-of-a-calling-Bash-script.html
function get_calling_file() {
  echo $(realpath $(ps -f -p $PPID | tail -1 | awk '{print $NF}'))
}

# Read locality variable from configuration file 
function read_locality_config() {
  locality_config="${HOME}/.config/.locality"
  if [[ ! -f ${locality_config} ]]; then exit 1; fi
  
  source "${locality_config}"

  if [[ -z $LOCALITY ]]; then exit 1; fi
  echo "${LOCALITY}"
}

function usage() {
  echo "usage"
}


# Prepends a string to the file name in the given path
#
# Arguments:
# 
#   $1 - The file path
#   $2 - The string to prepend
# 
# Examples: 
#  
#  modify_file_name ~/test/.zshrc loc1 -> ~/test/loc1.zshrc
#
function modify_file_name() {
  local filePath=$1
  local locality=$2
  local regex="^(.+/)\.?([^/]+)$"
  sed -E 's|'"${regex}"'|\1'"${locality}"'.\2|' <<< "${filePath}"
}

function sourced() {
  [ "${0}" != "${BASH_SOURCE[0]}" ]  
}


# Execute only if not sourced, e.g. run directly from shell
# See https://stackoverflow.com/a/23009039/2553104
if ! sourced; then locality "$@"; fi
